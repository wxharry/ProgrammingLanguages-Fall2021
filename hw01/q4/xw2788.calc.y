%{
#include <iostream>
#include <cstdio>
#include <math.h>

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { std::cerr << "error: " << p << std::endl; };
%}

%union {
    float val;
};

%start program_input

%token EOL
%token PI
%token L_BRACKET R_BRACKET
%token ADD SUB MUL DIV ABS SQRT POW MOD
%token LOG2 LOG10
%token CEIL FLOOR
%token SIN COS TAN
%token FACTORIAL // !
%token VARIABLE EQUALS VAR_KEYWORD

%token GBP_TO_USD USD_TO_GBP GBP_TO_EURO
%token EURO_TO_GBP USD_TO_EURO EURO_TO_USD
%token CEL_TO_FAH FAH_TO_CEL
%token MI_TO_KM KM_TO_MI

%token <val> NUMBER


%type <val> constant
%type <val> expr function calculation line program_input

/* Resolve the ambiguity of the grammar by defining precedence. */

/* Order of directives will determine the precedence. */
%left ADD SUB    /* left means left-associativity. */
%left DIV MUL MOD
%left POW 

%%

program_input : /* EPSILON */
              | program_input line  {$$ = $2;}
              ;

line : EOL
     | calculation EOL             {std::printf("= %.2f\n", $1);}
     ;

calculation : expr
            | assignment
            ;

constant : PI                       {$$ = 3.14;}
         ;

expr : SUB expr                     {$$ = 0 - $2;}
     | NUMBER                       
     | VARIABLE
     | constant
     | function                     
     | expr ADD expr                {$$ = $1 + $3;}
     | expr SUB expr                {$$ = $1 - $3;}
     | expr DIV expr                {$$ = $1 / $3;}
     | expr MUL expr                {$$ = $1 * $3;}
     | expr MOD expr                {$$ = int($1) % int($3);}
     | expr POW expr                {$$ = pow($1, $3);}
     | L_BRACKET expr R_BRACKET     {$$ = $2;}
     ;


function : conversion
         | log_function
         | trig_function
         | expr FACTORIAL
         | SQRT expr
         | ABS expr
         | FLOOR expr
         | CEIL expr
         ;

trig_function : COS expr
              | SIN expr
              | TAN expr
              ;

log_function : LOG2 expr
             | LOG10 expr
             ;

conversion : temp_conversion
           | dist_conversion
           | expr GBP_TO_USD
           | expr USD_TO_GBP
           | expr GBP_TO_EURO
           | expr EURO_TO_GBP
           | expr USD_TO_EURO
           | expr EURO_TO_USD
           ;

temp_conversion : expr CEL_TO_FAH
                | expr FAH_TO_CEL
                ;

dist_conversion : expr MI_TO_KM
                | expr KM_TO_MI
                ;

assignment: VAR_KEYWORD VARIABLE EQUALS calculation
          ;

%%

int main()
{
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}