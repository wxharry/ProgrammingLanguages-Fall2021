%{
#include <iostream>
#include <cstdio>
#include <cmath>
#include <map>

#include "util.h"
using namespace std;

#define CONST_PI 3.14
int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { cerr << "error: " << p << endl; };
extern FILE *yyin;
%}

%union {
    double val;
};

%start program_input

%token EOL
%token PI
%token L_BRACKET R_BRACKET
%token ADD SUB MUL DIV ABS SQRT POW MOD
%token LOG2 LOG10
%token CEIL FLOOR
%token SIN COS TAN
%token FACTORIAL // !
%token VARIABLE EQUALS VAR_KEYWORD

%token GBP_TO_USD USD_TO_GBP GBP_TO_EURO
%token EURO_TO_GBP USD_TO_EURO EURO_TO_USD
%token CEL_TO_FAH FAH_TO_CEL
%token MI_TO_KM KM_TO_MI

%token <val> NUMBER


%type <val> constant
%type <val> expr calculation line program_input
%type <val> function trig_function log_function
%type <val> conversion temp_conversion dist_conversion

/* Resolve the ambiguity of the grammar by defining precedence. */

/* Order of directives will determine the precedence. */
%left ADD SUB    /* left means left-associativity. */
%left DIV MUL MOD
%left POW 

%%

program_input : /* EPSILON */
              | program_input line  {$$ = $2;}
              ;

line : EOL                          {cout << endl;}
     | calculation EOL              {printf("= %.2f\n", $1);}
     ;

calculation : expr
            | assignment
            ;

constant : PI                       {$$ = CONST_PI;}
         ;

expr : SUB expr                     {$$ = 0 - $2;}
     | NUMBER                       
     | VARIABLE
     | constant
     | function                     
     | expr ADD expr                {$$ = $1 + $3;}
     | expr SUB expr                {$$ = $1 - $3;}
     | expr DIV expr                {$$ = $1 / $3;}
     | expr MUL expr                {$$ = $1 * $3;}
     | expr MOD expr                {$$ = modulo($1, $3);}
     | expr POW expr                {$$ = pow($1, $3);}
     | L_BRACKET expr R_BRACKET     {$$ = $2;}
     ;


function : conversion
         | log_function
         | trig_function
         | expr FACTORIAL           {$$ = factorial($1);}
         | SQRT expr                {$$ = sqrt($2);}
         | ABS expr                 {$$ = abs($2);}
         | FLOOR expr               {$$ = floor($2);}
         | CEIL expr                {$$ = ceil($2);}
         ;

trig_function : COS expr            {$$ = cos($2);}
              | SIN expr            {$$ = sin($2);}
              | TAN expr            {$$ = tan($2);}
              ;

log_function : LOG2 expr            {$$ = log($2)/log(2);} 
             | LOG10 expr           {$$ = log10($2);}
             ;

conversion : temp_conversion
           | dist_conversion
           | expr GBP_TO_USD        { $$ = gbp_to_usd($1);}
           | expr USD_TO_GBP        { $$ = usd_to_gbp($1);}
           | expr GBP_TO_EURO       { $$ = gbp_to_euro($1);}
           | expr EURO_TO_GBP       { $$ = euro_to_gbp($1);}
           | expr USD_TO_EURO       { $$ = usd_to_euro($1);}
           | expr EURO_TO_USD       { $$ = euro_to_usd($1);}
           ;

temp_conversion : expr CEL_TO_FAH   { $$ = cel_to_fah($1);}
                | expr FAH_TO_CEL   { $$ = fah_to_cel($1);}
                ;

dist_conversion : expr MI_TO_KM     { $$ = m_to_km($1);}
                | expr KM_TO_MI     { $$ = km_to_m($1);}
                ;

assignment: VAR_KEYWORD VARIABLE EQUALS calculation
          ;

%%

int main(int, char**)
{
    // open a file handle to a particular file:
    FILE *myfile = fopen("xw2788.input.txt", "r");
    // make sure it's valid:
    if (!myfile) {
        cout << "Cannot find xw2788.input.txt!" << endl;
        cout << "Please input in the command line:" << endl;
    }else{
        yyin = myfile;
    }
    // set lex to read from it instead of defaulting to STDIN:
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}
