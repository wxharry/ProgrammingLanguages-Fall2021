%{
#include <iostream>
#include <cstdio>
#include "util.h"
#include <math.h>
using namespace std;

int yylex(); // A function that is to be generated and provided by flex,
             // which returns a next token when called repeatedly.
int yyerror(const char *p) { cerr << "error: " << p << endl; };
extern FILE *yyin;
%}

%union {
    double val;
};

%start program_input

%token EOL
%token PI
%token L_BRACKET R_BRACKET
%token ADD SUB MUL DIV ABS SQRT POW MOD
%token LOG2 LOG10
%token CEIL FLOOR
%token SIN COS TAN
%token FACTORIAL // !
%token VARIABLE EQUALS VAR_KEYWORD

%token GBP_TO_USD USD_TO_GBP GBP_TO_EURO
%token EURO_TO_GBP USD_TO_EURO EURO_TO_USD
%token CEL_TO_FAH FAH_TO_CEL
%token MI_TO_KM KM_TO_MI

%token <val> NUMBER


%type <val> constant
%type <val> expr function calculation line program_input
%type <val> conversion temp_conversion dist_conversion

/* Resolve the ambiguity of the grammar by defining precedence. */

/* Order of directives will determine the precedence. */
%left ADD SUB    /* left means left-associativity. */
%left DIV MUL MOD
%left POW 

%%

program_input : /* EPSILON */
              | program_input line  {$$ = $2;}
              ;

line : EOL
     | calculation EOL             {printf("= %.2f\n", $1);}
     ;

calculation : expr
            | assignment
            ;

constant : PI                       {$$ = 3.14;}
         ;

expr : SUB expr                     {$$ = 0 - $2;}
     | NUMBER                       
     | VARIABLE
     | constant
     | function                     
     | expr ADD expr                {$$ = $1 + $3;}
     | expr SUB expr                {$$ = $1 - $3;}
     | expr DIV expr                {$$ = $1 / $3;}
     | expr MUL expr                {$$ = $1 * $3;}
     | expr MOD expr                {$$ = modulo($1, $3);}
     | expr POW expr                {$$ = pow($1, $3);}
     | L_BRACKET expr R_BRACKET     {$$ = $2;}
     ;


function : conversion
         | log_function
         | trig_function
         | expr FACTORIAL
         | SQRT expr
         | ABS expr
         | FLOOR expr
         | CEIL expr
         ;

trig_function : COS expr
              | SIN expr
              | TAN expr
              ;

log_function : LOG2 expr
             | LOG10 expr
             ;

conversion : temp_conversion
           | dist_conversion
           | expr GBP_TO_USD
           | expr USD_TO_GBP
           | expr GBP_TO_EURO
           | expr EURO_TO_GBP
           | expr USD_TO_EURO
           | expr EURO_TO_USD
           ;

temp_conversion : expr CEL_TO_FAH  
                | expr FAH_TO_CEL
                ;

dist_conversion : expr MI_TO_KM   
                | expr KM_TO_MI
                ;

assignment: VAR_KEYWORD VARIABLE EQUALS calculation
          ;

%%

int main(int, char**)
{
             
    // open a file handle to a particular file:
    FILE *myfile = fopen("xw2788.input.txt", "r");
    // make sure it's valid:
    if (!myfile) {
        cout << "I can't open input.txt!" << endl;
        cout << "Please input in the command line:" << endl;
    }else{
        yyin = myfile;
    }
    // set lex to read from it instead of defaulting to STDIN:
    yyparse(); // A parsing function that will be generated by Bison.
    return 0;
}
